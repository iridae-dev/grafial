// Example: Competing Choices with Categorical Posterior
// Demonstrates mutually exclusive routing where probabilities must sum to 1
// This is fundamentally different from independent Bernoulli edges

schema PacketRouting {
  node Router {
    latency: Real
  }
  edge ROUTES_TO { }
}

belief_model RoutingBeliefs on PacketRouting {
  node Router {
    latency ~ GaussianPosterior(prior_mean=50.0, prior_precision=0.1)
  }
  edge ROUTES_TO {
    // Competing edges: each router routes to exactly ONE destination
    // Probabilities sum to 1.0 within each group
    exist ~ CategoricalPosterior(
      group_by="source",
      prior=uniform,
      pseudo_count=1.0
    )
  }
}

evidence RoutingEvidence on RoutingBeliefs {
  // Dirichlet posterior mechanics for competing choices:
  // Initial uniform prior with pseudo_count=1.0:
  // - If 2 destinations exist: α = [0.5, 0.5] (split pseudo_count equally)
  // - E[π_R2] = E[π_R3] = 0.5

  // Router R1 chooses R2
  observe edge ROUTES_TO(Router["R1"], Router["R2"]) chosen
  // After R2 chosen: α = [1.5, 0.5] → P(R2)=0.75, P(R3)=0.25

  // Router R1 chooses R3 (conflicting with previous choice)
  observe edge ROUTES_TO(Router["R1"], Router["R3"]) chosen
  // After R3 chosen: α = [1.5, 1.5] → P(R2)=0.5, P(R3)=0.5
  // Now balanced: 1 observation each + 0.5 pseudo-count each
  // High entropy indicates uncertainty

  // Router R4 chooses R5
  observe edge ROUTES_TO(Router["R4"], Router["R5"]) chosen

  // Dynamic category discovery: R1 routes to R6 (new destination)
  // α automatically expands: [1.5, 1.5] → [1.5, 1.5, 1.0]
  // Preserves existing evidence, adds new category with prior only
  observe edge ROUTES_TO(Router["R1"], Router["R6"]) chosen
  // After R6 chosen: α = [1.5, 1.5, 2.0] → P(R2)≈0.3, P(R3)≈0.3, P(R6)≈0.4
}

// Rule that uses winner() - deterministic decision when there's a clear winner
rule OptimizeLatency on RoutingBeliefs {
  pattern
    (A:Router)-[ab:ROUTES_TO]->(B:Router)
  
  where
    // Only apply if B is the clear winner (not tied)
    winner(A, ROUTES_TO) == B
    and E[B.latency] < E[A.latency]
  
  action {
    // Route to faster destination
    // But this is still probabilistic - we're updating beliefs, not forcing
    set_expectation A.latency = E[A.latency] * 0.9
  }
  
  mode: for_each
}

// Rule that detects high uncertainty (no clear winner)
rule HandleUncertainRoute on RoutingBeliefs {
  pattern
    (A:Router)-[dummy:ROUTES_TO]->(A:Router)  // Need pattern even if just checking entropy

  where
    // High entropy means no clear winner - routing decision is uncertain
    // Entropy > 1.0 indicates multiple viable destinations with similar probabilities
    entropy(A, ROUTES_TO) > 1.0

  action {
    // Flag router for manual review by adjusting latency (proxy for attention)
    // In production, this might trigger an alert or additional data collection
    set_expectation A.latency = E[A.latency] * 1.1
  }

  mode: for_each
}

flow RoutingPipeline on RoutingBeliefs {
  graph base = from_evidence RoutingEvidence
  
  // Apply optimization only when there's a clear winner
  graph optimized = base |> apply_rule OptimizeLatency
  
  // Handle uncertain cases separately
  graph reviewed = optimized |> apply_rule HandleUncertainRoute
  
  // Metrics that understand competing probabilities
  metric avg_entropy = sum_nodes(
    label=Router,
    contrib=entropy(node, ROUTES_TO)
  ) / count_nodes(label=Router)
  
  metric deterministic_routes = count_nodes(
    label=Router,
    where=entropy(node, ROUTES_TO) < 0.5
  )
  
  export reviewed as "final_routing"
}


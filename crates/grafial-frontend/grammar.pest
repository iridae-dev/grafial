// Phase 1: grammar to build typed AST (no semantics)

WHITESPACE = _{ (" " | "\t" | "\r" | "\n")+ }
COMMENT = _{ LINE_COMMENT | BLOCK_COMMENT }
LINE_COMMENT = _{ "//" ~ (!("\n") ~ ANY)* }
BLOCK_COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

ident = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
label = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
string = @{ "\"" ~ ( "\\\"" | "\\\\" | (!"\"" ~ ANY) )* ~ "\"" }

program = { SOI ~ (COMMENT | decl)* ~ EOI }

decl = _{ schema_decl | belief_model_decl | evidence_decl | rule_decl | flow_decl }

// --- schema ---
schema_decl = { KW_schema ~ ident ~ block_schema }
block_schema = { "{" ~ (COMMENT | node_decl | edge_decl)* ~ "}" }
node_decl = { KW_node ~ ident ~ "{" ~ (COMMENT | attr_decl)* ~ "}" }
edge_decl = { KW_edge ~ ident ~ "{" ~ (COMMENT)* ~ "}" }
attr_decl = { ident ~ ":" ~ ident ~ ";"? }

// --- belief_model / evidence ---
belief_model_decl = { KW_belief_model ~ ident ~ KW_on ~ ident ~ belief_model_body }
belief_model_body = { "{" ~ (COMMENT | node_belief_decl | edge_belief_decl)* ~ "}" }
node_belief_decl = { KW_node ~ ident ~ "{" ~ (COMMENT | attr_belief_decl)* ~ "}" }
attr_belief_decl = { ident ~ "~" ~ posterior_type ~ ";"? }
edge_belief_decl = { KW_edge ~ ident ~ "{" ~ (COMMENT | exist_belief_decl)* ~ "}" }
exist_belief_decl = { "exist" ~ "~" ~ posterior_type ~ ";"? }

posterior_type = { gaussian_posterior | bernoulli_posterior | categorical_posterior }
gaussian_posterior = { ("GaussianPosterior" | "Gaussian") ~ "(" ~ gaussian_param ~ ("," ~ gaussian_param)* ~ ")" }
gaussian_param = { (ident ~ "=" ~ number) }
bernoulli_posterior = { ("BernoulliPosterior" | "Bernoulli") ~ "(" ~ bernoulli_param ~ ("," ~ bernoulli_param)* ~ ")" }
bernoulli_param = { (ident ~ "=" ~ number) }
categorical_posterior = { ("CategoricalPosterior" | "Categorical") ~ "(" ~ categorical_param ~ ("," ~ categorical_param)* ~ ")" }
categorical_param = {
    (ident ~ "=" ~ categorical_param_value)
}
categorical_param_value = {
    string | prior_array | "uniform" | ident | number | categorical_categories_array
}
categorical_categories_array = { "[" ~ string ~ ("," ~ string)* ~ "]" }
prior_array = { "[" ~ number ~ ("," ~ number)* ~ "]" }

evidence_decl = { KW_evidence ~ ident ~ KW_on ~ ident ~ evidence_body }
evidence_body = { "{" ~ (COMMENT | observe_stmt | choose_stmt | unchoose_stmt | node_group | edge_group)* ~ "}" }
// Grouped evidence sugar
node_group = { ident ~ "{" ~ (node_entry ~ ("," ~ node_entry)*)? ~ "}" }
node_entry = { node_label ~ "{" ~ (node_attr_kv ~ ("," ~ node_attr_kv)*)? ~ "}" }
node_attr_kv = { ident ~ ":" ~ number ~ precision_annot? }

edge_group = { ident ~ "(" ~ ident ~ "->" ~ ident ~ ")" ~ "{" ~ (edge_entry ~ ( (";" | ",") ~ edge_entry )* )? ~ "}" }
edge_op = { "->" | "-/>" }
edge_entry = { node_label ~ edge_op ~ node_label }
choose_stmt = { KW_choose ~ edge_observe ~ ";"? }
unchoose_stmt = { KW_unchoose ~ edge_observe ~ ";"? }
observe_stmt = { observe_edge_stmt | observe_attr_stmt }
observe_edge_stmt = { KW_observe ~ edge_observe ~ evidence_mode ~ ";"? }
observe_attr_stmt = { KW_observe ~ attr_observe ~ ";"? }
observe_target = { edge_observe | attr_observe }
edge_observe = { KW_edge ~ ident ~ "(" ~ node_ref ~ "," ~ node_ref ~ ")" }
attr_observe = { node_ref ~ "." ~ ident ~ "=" ~ number ~ precision_annot? }
precision_annot = { "(" ~ ident ~ "=" ~ number ~ ")" }
// Node reference supports both bracket and call-style forms:
// - Label["id"]  (original)
// - Label("id")  (string)
// - Label(id)    (identifier or number)
node_ref = { ident ~ ( node_ref_bracket | node_ref_call ) }
node_ref_bracket = { "[" ~ string ~ "]" }
node_ref_call = { "(" ~ node_label ~ ")" }
node_label = { string | ident | number }
evidence_mode = { "present" | "absent" | "chosen" | "unchosen" | "forced_choice" }

kw_observe_tok = @{ "observe" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_observe = _{ kw_observe_tok }
kw_choose_tok = @{ "choose" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_unchoose_tok = @{ "unchoose" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_choose = _{ kw_choose_tok }
KW_unchoose = _{ kw_unchoose_tok }

// Balanced block text (captures nested braces) - for evidence and other opaque bodies
block = { "{" ~ block_inner* ~ "}" }
block_inner = _{ block | (!("{" | "}") ~ ANY) }

// --- rule ---
rule_decl = { KW_rule ~ ident ~ KW_on ~ ident ~ "{" ~ rule_body ~ "}" }
rule_body = { (COMMENT | sugar_rule | for_sugar | pattern_clause | where_clause | action_clause | mode_clause )* }
// Sugar: single-line pattern with optional where and arrow to action block
sugar_rule = { pattern_item ~ (KW_where ~ expr)? ~ "=>" ~ action_block }
// Node-only sugar: for (Var:Label) [where expr]? => { actions }
for_sugar = { KW_for ~ "(" ~ ident ~ ":" ~ label ~ ")" ~ (KW_where ~ expr)? ~ "=>" ~ action_block }

pattern_clause = { KW_pattern ~ pattern_list }
pattern_list = { pattern_item ~ ("," ~ pattern_item)* }
pattern_item = {
    "(" ~ ident ~ ":" ~ label ~ ")" ~ "-" ~ "[" ~ ident ~ ":" ~ ident ~ "]" ~ "->" ~ "(" ~ ident ~ ":" ~ label ~ ")"
}

where_clause = { KW_where ~ expr ~ ("=>" ~ action_block)? }

action_clause = { KW_action ~ action_block }
action_block = { "{" ~ (COMMENT | action_stmt)* ~ "}" }
action_stmt = { let_stmt | nbnudge_stmt | soft_update_stmt | delete_stmt | suppress_stmt }
let_stmt = { KW_let ~ ident ~ "=" ~ expr ~ ";"? }
node_attr = { ident ~ "." ~ ident }
nbnudge_stmt = { KW_non_bayesian_nudge ~ node_attr ~ KW_to ~ expr ~ variance_clause? ~ ";"? }
variance_clause = { KW_variance ~ "=" ~ ( KW_preserve | increase_clause | decrease_clause ) }
increase_clause = { KW_increase ~ ( "(" ~ "factor" ~ "=" ~ number ~ ")" )? }
decrease_clause = { KW_decrease ~ ( "(" ~ "factor" ~ "=" ~ number ~ ")" )? }
soft_update_stmt = { node_attr ~ "~=" ~ expr ~ (soft_args | soft_arg)* ~ ";"? }
soft_args = { "(" ~ soft_arg ~ ( "," ~ soft_arg )* ~ ")" }
soft_arg = { ( "precision" ~ "=" ~ number ) | ( "count" ~ "=" ~ number ) }
delete_stmt = { KW_delete ~ ident ~ (delete_args | delete_arg)? ~ ";"? }
delete_args = { "(" ~ delete_arg ~ ")" }
delete_arg = { "confidence" ~ "=" ~ ident }
suppress_stmt = { KW_suppress ~ ident ~ (suppress_args | suppress_arg)? ~ ";"? }
suppress_args = { "(" ~ suppress_arg ~ ")" }
suppress_arg = { "weight" ~ "=" ~ number }
mode_clause = { KW_mode ~ ":" ~ ident }

// --- flow ---
flow_decl = { KW_flow ~ ident ~ KW_on ~ ident ~ "{" ~ flow_body ~ "}" }
flow_body = { (COMMENT | graph_stmt | metric_stmt | export_stmt | metric_export_stmt | metric_import_stmt)* }

graph_stmt = { KW_graph ~ ident ~ "=" ~ graph_expr }
graph_expr = { from_evidence_expr | from_graph_expr | pipeline_expr }
from_evidence_expr = { KW_from_evidence ~ ident }
from_graph_expr = { KW_from_graph ~ string }
pipeline_expr = { ident ~ (pipe_op ~ transform)+ }
pipe_op = { "|>" }

transform = _{ apply_rule_tr | apply_ruleset_tr | snapshot_tr | prune_edges_tr }
apply_rule_tr = { KW_apply_rule ~ ident }
apply_ruleset_tr = { KW_apply_ruleset ~ "{" ~ ident ~ ("," ~ ident)* ~ "}" }
snapshot_tr = { KW_snapshot ~ string }
prune_edges_tr = { KW_prune_edges ~ ident ~ KW_where ~ expr }

metric_stmt = { KW_metric ~ ident ~ "=" ~ (metric_builder_expr | expr) }

// Metric builder pipeline: nodes(Label) |> where(expr)? |> (sum(by=expr) | count() | avg(by=expr) | fold(init=expr, step=expr, order_by=expr) )
metric_builder_expr = { builder_start ~ (pipe_op ~ builder_step)+ }
builder_start = { KW_nodes ~ "(" ~ label ~ ")" }
builder_step = { builder_where | builder_sum | builder_count | builder_avg | builder_fold | builder_order }
builder_where = { KW_where ~ expr }
builder_sum = { KW_sum ~ "(" ~ "by" ~ "=" ~ expr ~ ")" }
builder_count = { KW_count ~ "(" ~ ")" }
builder_avg = { KW_avg ~ "(" ~ "by" ~ "=" ~ expr ~ ")" }
builder_order = { KW_order_by ~ "(" ~ expr ~ ")" }
builder_fold = { KW_fold ~ "(" ~ fold_args ~ ")" }
fold_args = { fold_arg ~ ( "," ~ fold_arg )* }
fold_arg = { ("init" ~ "=" ~ expr) | ("step" ~ "=" ~ expr) | ("order_by" ~ "=" ~ expr) }
export_stmt = { KW_export ~ ident ~ KW_as ~ string }
metric_export_stmt = { KW_export_metric ~ ident ~ KW_as ~ string }
metric_import_stmt = { KW_import_metric ~ ident ~ KW_as ~ ident }

// --- expressions ---
expr = { or_expr }
or_expr = { and_expr ~ (op_or ~ and_expr)* }
op_or = { kw_or_tok }
and_expr = { cmp_expr ~ (op_and ~ cmp_expr)* }
op_and = { kw_and_tok }
cmp_expr = { add_expr ~ (op_cmp ~ add_expr)? }
op_cmp = { "==" | "!=" | "<=" | ">=" | "<" | ">" }
add_expr = { mul_expr ~ ((op_add) ~ mul_expr)* }
op_add = { "+" | "-" }
mul_expr = { unary_expr ~ ((op_mul) ~ unary_expr)* }
op_mul = { "*" | "/" }
unary_expr = { (op_unary ~ unary_expr) | postfix }
op_unary = { "-" | kw_not_tok }
call_primary = _{ e_bracket | paren_expr | exists_expr | not_exists_expr | metric_builder_expr | ident }
postfix = { ((number | boolean) ~ field_access*) | (call_primary ~ ( field_access | call_suffix )*) }
field_access = { "." ~ ident }
call_suffix = { "(" ~ (arg ~ ("," ~ arg)*)? ~ ")" }
arg = _{ named_arg | expr }
named_arg = { ident ~ "=" ~ expr }
// Put exists/not exists before ident so keywords aren't captured as identifiers
primary = { number | boolean | e_bracket | paren_expr | exists_expr | not_exists_expr | metric_builder_expr | ident }
paren_expr = { "(" ~ expr ~ ")" }
e_bracket = { "E" ~ "[" ~ (ident ~ "." ~ ident) ~ "]" }
exists_expr = { KW_exists ~ pattern_item ~ (KW_where ~ expr)? }
not_exists_expr = { KW_not ~ KW_exists ~ pattern_item ~ (KW_where ~ expr)? }
number = @{ ("-")? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
boolean = _{ KW_true | KW_false }

// Keywords with word boundaries (atomic match wrapped in silent rule)
kw_schema_tok = @{ "schema" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_node_tok = @{ "node" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_edge_tok = @{ "edge" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_belief_model_tok = @{ "belief_model" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_on_tok = @{ "on" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_evidence_tok = @{ "evidence" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_rule_tok = @{ "rule" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_for_tok = @{ "for" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_pattern_tok = @{ "pattern" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_where_tok = @{ "where" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_action_tok = @{ "action" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_mode_tok = @{ "mode" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_flow_tok = @{ "flow" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_graph_tok = @{ "graph" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_from_evidence_tok = @{ "from_evidence" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_from_graph_tok = @{ "from_graph" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_apply_rule_tok = @{ "apply_rule" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_apply_ruleset_tok = @{ "apply_ruleset" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_snapshot_tok = @{ "snapshot" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_prune_edges_tok = @{ "prune_edges" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_metric_tok = @{ "metric" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_nodes_tok = @{ "nodes" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_sum_tok = @{ "sum" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_count_tok = @{ "count" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_avg_tok = @{ "avg" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_order_by_tok = @{ "order_by" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_fold_tok = @{ "fold" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_export_tok = @{ "export" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_as_tok = @{ "as" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_export_metric_tok = @{ "export_metric" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_import_metric_tok = @{ "import_metric" ~ !(ASCII_ALPHANUMERIC | "_") }

KW_schema = _{ kw_schema_tok }
KW_node = _{ kw_node_tok }
KW_edge = _{ kw_edge_tok }
KW_belief_model = _{ kw_belief_model_tok }
KW_on = _{ kw_on_tok }
KW_evidence = _{ kw_evidence_tok }
KW_rule = _{ kw_rule_tok }
KW_for = _{ kw_for_tok }
KW_pattern = _{ kw_pattern_tok }
KW_where = _{ kw_where_tok }
KW_action = _{ kw_action_tok }
// Additional keywords for new action syntax
kw_to_tok = @{ "to" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_non_bayesian_nudge_tok = @{ "non_bayesian_nudge" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_delete_tok = @{ "delete" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_suppress_tok = @{ "suppress" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_variance_tok = @{ "variance" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_preserve_tok = @{ "preserve" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_increase_tok = @{ "increase" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_decrease_tok = @{ "decrease" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_mode = _{ kw_mode_tok }
KW_flow = _{ kw_flow_tok }
KW_graph = _{ kw_graph_tok }
KW_from_evidence = _{ kw_from_evidence_tok }
KW_from_graph = _{ kw_from_graph_tok }
KW_apply_rule = _{ kw_apply_rule_tok }
KW_apply_ruleset = _{ kw_apply_ruleset_tok }
KW_snapshot = _{ kw_snapshot_tok }
KW_prune_edges = _{ kw_prune_edges_tok }
KW_metric = _{ kw_metric_tok }
KW_nodes = _{ kw_nodes_tok }
KW_sum = _{ kw_sum_tok }
KW_count = _{ kw_count_tok }
KW_avg = _{ kw_avg_tok }
KW_order_by = _{ kw_order_by_tok }
KW_fold = _{ kw_fold_tok }
KW_export = _{ kw_export_tok }
KW_as = _{ kw_as_tok }
KW_export_metric = _{ kw_export_metric_tok }
KW_import_metric = _{ kw_import_metric_tok }
kw_let_tok = @{ "let" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_exists_tok = @{ "exists" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_and_tok = @{ "and" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_or_tok = @{ "or" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_not_tok = @{ "not" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_true_tok = @{ "true" ~ !(ASCII_ALPHANUMERIC | "_") }
kw_false_tok = @{ "false" ~ !(ASCII_ALPHANUMERIC | "_") }

KW_and = _{ kw_and_tok }
KW_or = _{ kw_or_tok }
KW_not = _{ kw_not_tok }
KW_true = _{ kw_true_tok }
KW_false = _{ kw_false_tok }
KW_let = _{ kw_let_tok }
KW_exists = _{ kw_exists_tok }
KW_to = _{ kw_to_tok }
KW_non_bayesian_nudge = _{ kw_non_bayesian_nudge_tok }
KW_delete = _{ kw_delete_tok }
KW_suppress = _{ kw_suppress_tok }
KW_variance = _{ kw_variance_tok }
KW_preserve = _{ kw_preserve_tok }
KW_increase = _{ kw_increase_tok }
KW_decrease = _{ kw_decrease_tok }

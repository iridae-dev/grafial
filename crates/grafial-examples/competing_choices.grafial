// Example: Competing Choices with Categorical Posterior
// Demonstrates mutually exclusive routing where probabilities must sum to 1
// This is fundamentally different from independent Bernoulli edges

schema PacketRouting {
  node Router {
    latency: Real
  }
  edge ROUTES_TO { }
}

belief_model RoutingBeliefs on PacketRouting {
  node Router {
    latency ~ Gaussian(mean=50.0, precision=0.1)
  }
  edge ROUTES_TO {
    // Competing edges: each router routes to exactly ONE destination
    // Probabilities sum to 1.0 within each group
    exist ~ Categorical(
      group_by=source,
      prior=uniform,
      pseudo_count=1.0
    )
  }
}

evidence RoutingEvidence on RoutingBeliefs {
  // Dirichlet posterior mechanics for competing choices:
  // Initial uniform prior with pseudo_count=1.0:
  // - If 2 destinations exist: α = [0.5, 0.5] (split pseudo_count equally)
  // - E[π_R2] = E[π_R3] = 0.5

  // Router R1 chooses R2
  choose edge ROUTES_TO(Router["R1"], Router["R2"]) 
  // After R2 chosen: α = [1.5, 0.5] → P(R2)=0.75, P(R3)=0.25

  // Router R1 chooses R3 (conflicting with previous choice)
  choose edge ROUTES_TO(Router["R1"], Router["R3"]) 
  // After R3 chosen: α = [1.5, 1.5] → P(R2)=0.5, P(R3)=0.5
  // Now balanced: 1 observation each + 0.5 pseudo-count each
  // High entropy indicates uncertainty

  // Router R4 chooses R5
  choose edge ROUTES_TO(Router["R4"], Router["R5"]) 

  // Dynamic category discovery: R1 routes to R6 (new destination)
  // α automatically expands: [1.5, 1.5] → [1.5, 1.5, 1.0]
  // Preserves existing evidence, adds new category with prior only
  choose edge ROUTES_TO(Router["R1"], Router["R6"]) 
  // After R6 chosen: α = [1.5, 1.5, 2.0] → P(R2)≈0.3, P(R3)≈0.3, P(R6)≈0.4
}

// Rule that uses winner() - deterministic decision when there's a clear winner
rule OptimizeLatency on RoutingBeliefs {
  pattern
    (A:Router)-[ab:ROUTES_TO]->(B:Router)
  
  where
    // Only apply if B is the clear winner (not tied)
    winner(A, ROUTES_TO) == B
    and E[B.latency] < E[A.latency]
  
  action {
    // Route to faster destination
    // But this is still probabilistic - we're updating beliefs, not forcing
    non_bayesian_nudge A.latency to E[A.latency] * 0.9 variance=preserve
  }
  
  mode: for_each
}

// Rule that detects high uncertainty (no clear winner)
rule HandleUncertainRoute on RoutingBeliefs {
  pattern
    (A:Router)-[dummy:ROUTES_TO]->(A:Router)  // Need pattern even if just checking entropy

  where
    // High entropy means no clear winner - routing decision is uncertain
    // Entropy > 1.0 indicates multiple viable destinations with similar probabilities
    entropy(A, ROUTES_TO) > 1.0

  action {
    // Flag router for manual review by adjusting latency (proxy for attention)
    // In production, this might trigger an alert or additional data collection
    non_bayesian_nudge A.latency to E[A.latency] * 1.1 variance=preserve
  }

  mode: for_each
}

flow RoutingPipeline on RoutingBeliefs {
  graph base = from_evidence RoutingEvidence
  
  // Apply optimization only when there's a clear winner
  graph optimized = base |> apply_rule OptimizeLatency
  
  // Handle uncertain cases separately
  graph reviewed = optimized |> apply_rule HandleUncertainRoute
  
  // Metrics that understand competing probabilities
  metric avg_entropy = nodes(Router)
    |> avg(by=entropy(node, ROUTES_TO))
  
  metric deterministic_routes = nodes(Router)
    |> where(entropy(node, ROUTES_TO) < 0.5)
    |> count()
  
  export reviewed as "final_routing"
}

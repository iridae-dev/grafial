// Example: Probabilistic Pattern Matching
// Demonstrates how rules match based on probability distributions, not just
// hard facts. This is fundamentally different from deterministic graph queries.

schema SocialNetwork {
  node Person {
    influence: Real
    trust_level: Real
  }
  edge FRIENDS { }
  edge INFLUENCES { }
}

belief_model SocialBeliefs on SocialNetwork {
  node Person {
    influence ~ Gaussian(mean=0.5, precision=0.1)
    trust_level ~ Gaussian(mean=0.5, precision=0.1)
  }
  // Friendship is uncertain - we observe connections but aren't 100% sure
  edge FRIENDS { exist ~ Bernoulli(prior=0.1, weight=2.0) }
  edge INFLUENCES { exist ~ Bernoulli(prior=0.05, weight=5.0) }
}

evidence SocialEvidence on SocialBeliefs {
  // Initial observations: some friendships are more certain than others
  FRIENDS(Person -> Person) { "Alice" -> "Bob"; "Alice" -> "Bob"; "Bob" -> "Carol" }
  
  // Influence relationships
  INFLUENCES(Person -> Person) { "Alice" -> "Bob" }
  
  // Person attributes
  Person {
    "Alice" { influence: 0.8 },
    "Bob"   { influence: 0.6 },
    "Carol" { influence: 0.4 }
  }
}

// Rule that matches probabilistically: find influential people who likely
// influence their friends, even if we're not 100% certain
rule PropagateInfluence on SocialBeliefs {
  pattern
    (A:Person)-[ab:FRIENDS]->(B:Person),
    (A:Person)-[ai:INFLUENCES]->(B:Person)
  
  where
    // Probabilistic matching: match if P(friends) >= 0.7 AND P(influences) >= 0.6
    // This is a soft threshold - not a hard boolean
    prob(ab) >= 0.7
    and prob(ai) >= 0.6
    and E[A.influence] > E[B.influence]
  
  action {
    // Soft update: increase B's influence based on A's, but preserve uncertainty
    let influence_transfer = (E[A.influence] - E[B.influence]) * 0.1
    non_bayesian_nudge B.influence to E[B.influence] + influence_transfer variance=preserve
  }
  
  mode: for_each
}

// Rule that uses exists subquery to find indirect connections
// NOTE: Current implementation supports single-hop exists patterns only
// Two-hop patterns (A->X->B) require fixpoint iteration instead
rule IndirectInfluence on SocialBeliefs {
  pattern
    (A:Person)-[ab:FRIENDS]->(B:Person)

  where
    // A has high-probability influence on someone (one-hop check)
    // For multi-hop inference, use fixpoint mode instead (see transitive_closure.grafial)
    prob(ab) >= 0.8
    and exists (A:Person)-[ax:INFLUENCES]->(X:Person) where prob(ax) >= 0.7 and X != B

  action {
    // Indirect influence: weaker than direct
    let influence_transfer = (E[A.influence] - E[B.influence]) * 0.05
    non_bayesian_nudge B.influence to E[B.influence] + influence_transfer variance=preserve
  }

  mode: for_each
}

// Rule demonstrating 'not exists' for finding isolated nodes
rule BoostIsolatedNodes on SocialBeliefs {
  pattern
    (A:Person)-[dummy:FRIENDS]->(A:Person)  // Self-reference pattern

  where
    // Check if A lacks strong outgoing friendships
    not exists (A:Person)-[af:FRIENDS]->(F:Person) where prob(af) >= 0.5 and F != A

  action {
    // Boost influence for isolated but valuable nodes
    non_bayesian_nudge A.influence to E[A.influence] * 1.1 variance=preserve
  }

  mode: for_each
}

// Rule that prunes low-probability edges while preserving uncertainty
rule PruneWeakConnections on SocialBeliefs {
  pattern
    (A:Person)-[ab:FRIENDS]->(B:Person)
  
  where
    // Only remove if we're reasonably certain it doesn't exist
    prob(ab) < 0.1
  
  action {
    // Force absent: but this is still probabilistic (sets to near-zero, not exactly zero)
    delete ab confidence=high
  }
  
  mode: for_each
}

flow SocialAnalysis on SocialBeliefs {
  graph base = from_evidence SocialEvidence
  
  // Apply direct influence propagation
  graph step1 = base |> apply_rule PropagateInfluence
  
  // Apply indirect influence
  graph step2 = step1 |> apply_rule IndirectInfluence
  
  // Clean up weak connections
  graph cleaned = step2 |> apply_rule PruneWeakConnections
  
  // Metrics that understand probabilistic structure
  metric avg_influence = nodes(Person) |> avg(by=E[node.influence])
  
  metric avg_strong_connections = avg_degree(Person, FRIENDS, min_prob=0.8)
  
  // Count nodes with many weak connections (uncertain structure)
  metric uncertain_connections = nodes(Person)
    |> where(degree(node, min_prob=0.3) > degree(node, min_prob=0.7))
    |> count()
  
  export cleaned as "influence_graph"
}

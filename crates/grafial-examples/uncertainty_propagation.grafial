// Example: Uncertainty Propagation Through Evidence
// Demonstrates how Bayesian updates accumulate evidence and how rules
// can reason probabilistically when information is incomplete

schema FraudDetection {
  node Transaction {
    amount: Real
    risk_score: Real
  }
  edge SUSPICIOUS { }
}

belief_model FraudBeliefs on FraudDetection {
  node Transaction {
    // Prior: most transactions are safe (low risk)
    risk_score ~ Gaussian(mean=0.2, precision=0.1)  // Weak prior - uncertain initially
    amount ~ Gaussian(mean=100.0, precision=0.01)
  }
  edge SUSPICIOUS {
    // Prior: only 1% of transactions are suspicious (rare event)
    // Beta(α, β) where α = prior × pseudo_count, β = (1-prior) × pseudo_count
    exist ~ Bernoulli(
      prior=0.01,
      weight=10.0  // Moderate prior: Beta(0.1, 9.9)
      // After 1 positive observation: Beta(1.1, 9.9) → mean ≈ 0.10 (10x increase)
      // For stronger resistance to change, use pseudo_count=1000.0
    )
  }
}

evidence InitialEvidence on FraudBeliefs {
  // First observation: transaction amount
  Transaction { "T1" { amount: 5000.0 } }
  
  // Second observation: risk score (from external model)
  Transaction { "T1" { risk_score: 0.8 } }
  
  // Note: We haven't observed the edge yet, but we can still reason about it
}

evidence AdditionalEvidence on FraudBeliefs {
  // Sequential updates: this evidence builds on InitialEvidence
  // Bayesian inference combines ALL observations cumulatively
  Transaction { "T1" { risk_score: 0.9 } }

  // Bayesian update mechanics:
  // - Prior from InitialEvidence: risk_score ~ N(μ₁, τ₁) after first 0.8 observation
  // - New observation: 0.9 with precision τ_obs = 1.0 (default)
  // - Posterior: τ_new = τ₁ + 1.0, μ_new = (τ₁×μ₁ + 1.0×0.9) / τ_new
  // - Both 0.8 and 0.9 contribute to final posterior (not replacement)

  // Now we have direct edge evidence
  SUSPICIOUS(Transaction -> Transaction) { "T1" -> "T1" }

  // Edge update: Beta(0.1, 9.9) + 1 success → Beta(1.1, 9.9)
  // Mean shifts from 0.01 to 0.10 (10x increase, substantial for one observation)
  // Posterior variance decreases: more certain but still uncertain
  // This is proper Bayesian learning: gradual belief updates from evidence
}

// Rule that reasons probabilistically: flag transactions that are
// likely (but not certain) to be suspicious
rule FlagHighRisk on FraudBeliefs {
  pattern
    (T:Transaction)-[s:SUSPICIOUS]->(T:Transaction)
  
  where
    // Probabilistic threshold: flag if P(suspicious) > 0.3
    // This is a soft decision, not a hard boolean
    prob(s) >= 0.3
    or E[T.risk_score] > 0.7
    or (E[T.amount] > 10000.0 and E[T.risk_score] > 0.5)
  
  action {
    // Soft update: increase risk score but preserve uncertainty
    // This is different from a hard constraint - we're updating beliefs
    set_expectation T.risk_score = E[T.risk_score] * 1.1
  }
  
  mode: for_each
}

flow FraudAnalysis on FraudBeliefs {
  graph initial = from_evidence InitialEvidence
  graph with_additional = from_evidence AdditionalEvidence
  
  // Compare: how did probabilities change with more evidence?
  graph flagged = with_additional |> apply_rule FlagHighRisk
  
  // Metrics that reason about uncertainty
  metric avg_risk = nodes(Transaction) |> avg(by=E[node.risk_score])

  // Note: Can't use prob() in metrics because metrics operate on node sets,
  // not individual edges. Use degree() to count high-probability edges instead:
  metric suspicious_count = nodes(Transaction)
    |> where(E[node.risk_score] > 0.7)
    |> count()
  
  export flagged as "flagged_transactions"
}
